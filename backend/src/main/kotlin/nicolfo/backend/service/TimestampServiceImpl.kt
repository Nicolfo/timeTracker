package nicolfo.backend.service

import nicolfo.backend.dto.CurrentStatusDTO
import nicolfo.backend.dto.DailySummaryDTO
import nicolfo.backend.dto.TaskSummaryDTO
import nicolfo.backend.dto.TimestampDTO
import nicolfo.backend.dto.WeeklySummaryDTO
import nicolfo.backend.entity.Action
import nicolfo.backend.entity.TimestampEntry
import nicolfo.backend.repository.TimestampRegistry
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.time.temporal.ChronoUnit

@Service
@Transactional
class TimestampServiceImpl(
    private val timestampRepository: TimestampRegistry
) : TimestampService {
    override fun insertTimestamp(
        timestampDTO: TimestampDTO,
        username: String?
    ): Long? {
        val userId = username ?: "anonymous"
        val entry = TimestampEntry(
            userId = userId,
            timestamp = timestampDTO.timestamp!!,
            action = timestampDTO.action!!
        )
        timestampRepository.save(entry)
        return entry.id ?: throw IllegalStateException("Failed to generate ID for timestamp entry")
    }

    override fun getWeeklySummary(request: LocalDate, username: String?): WeeklySummaryDTO {
        val userId = username ?: "anonymous"
        val startOfWeek = request.minusDays(request.dayOfWeek.value.toLong() - 1)
        val endOfWeek = startOfWeek.plusDays(6)

        val dailySummaries = mutableListOf<DailySummaryDTO>()
        var totalMinutes = 0L

        var currentDate = startOfWeek
        while (!currentDate.isAfter(endOfWeek)) {
            val dailySummary = getDailySummary(currentDate, userId)
            dailySummaries.add(dailySummary)
            totalMinutes += dailySummary.totalMinutes
            currentDate = currentDate.plusDays(1)
        }

        return WeeklySummaryDTO(
            totalMinutes = totalMinutes,
            dailySummaries = dailySummaries
        )
    }

    override fun getDailySummary(request: LocalDate, username: String?): DailySummaryDTO {

        if (request.isAfter(LocalDate.now()))
            return DailySummaryDTO(request, 0, emptyList())

        val userId = username ?: "anonymous"
        val startOfDay = LocalDateTime.of(request, LocalTime.MIN)
        // End of day is now if the date is today
        // Otherwise it's the start of the next day
        val now = LocalDateTime.now()
        val endOfDay = if (request == now.toLocalDate()) now else startOfDay.plusDays(1)

        // Get all entries for the day
        val entries =
            timestampRepository.findAllByUserIdAndTimestampBetweenOrderByTimestampAsc(userId, startOfDay, endOfDay)
        val beforeTimestamp =
            timestampRepository.getFirstByUserIdAndTimestampLessThanOrderByTimestampDesc(userId, startOfDay)
        // Pair START and STOP actions to create tasks
        val tasks = mutableListOf<TaskSummaryDTO>()
        var startTime: LocalDateTime? =
            if (beforeTimestamp?.action == Action.START) startOfDay else null
        var autoGeneratedStart = startTime != null

        for (entry in entries) {
            when (entry.action) {

                Action.START -> {
                    startTime = entry.timestamp
                    autoGeneratedStart = false
                }

                Action.STOP -> {
                    // If we have a start time, create a task
                    if (startTime != null) {
                        val duration = ChronoUnit.MINUTES.between(startTime, entry.timestamp)
                        tasks.add(
                            TaskSummaryDTO(
                                startTime, entry.timestamp, duration,
                                autogeneratedStart = autoGeneratedStart,
                                autogeneratedStop = false
                            )
                        )
                        autoGeneratedStart = false
                        startTime = null
                    } else {
                        // this will never happen hopefully, default to autogenerated start time (but the db is broken)
                        println("Found STOP without a start time, using start of day")

                        startTime = entry.timestamp.withHour(0).withMinute(0).withSecond(0)
                        val duration = ChronoUnit.MINUTES.between(startTime, entry.timestamp)
                        tasks.add(
                            TaskSummaryDTO(
                                startTime,
                                entry.timestamp,
                                duration,
                                autogeneratedStart = true,
                                autogeneratedStop = true
                            )
                        )
                        startTime = null
                    }
                }
            }
        }

        // If there's a start without a stop at the end of the day, use end of day as stop
        if (startTime != null) {
            val duration = ChronoUnit.MINUTES.between(startTime, endOfDay)
            tasks.add(
                TaskSummaryDTO(
                    startTime,
                    endOfDay,
                    duration,
                    autogeneratedStart = autoGeneratedStart,
                    autogeneratedStop = true
                )
            )
        }

        // Calculate total minutes
        val totalMinutes = tasks.sumOf { it.duration }

        return DailySummaryDTO(
            date = request,
            totalMinutes = totalMinutes,
            tasks = tasks
        )
    }

    override fun getCurrentStatus(username: String?): CurrentStatusDTO {
        val userId = username ?: "anonymous"
        val lastEntry = timestampRepository.getFirstByUserIdOrderByTimestampDesc(userId)
        // If there's no entry, we're not running anything
        if (lastEntry == null) return CurrentStatusDTO(isTaskRunning = false, duration = null, startTime = null)
        val today = LocalDate.now()


        if (lastEntry.action == Action.STOP)
            return CurrentStatusDTO(isTaskRunning = false, duration = null, startTime = null)

        return CurrentStatusDTO(
            isTaskRunning = true,
            duration = lastEntry.let { ChronoUnit.MINUTES.between(it.timestamp, LocalDateTime.now()) },
            startTime = lastEntry.timestamp
        )
    }
}
